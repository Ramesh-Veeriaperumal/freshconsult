module Inherits
  module CustomField
    module InstanceMethods

      include CustomFields::Constants

      # scope_condition for acts_as_list
      def scope_condition
        "account_id = #{account_id}"
      end

      def field_class
        self.class::FIELD_PROPS
      end

      def dom_type
        field_class[field_type.to_sym][:dom_type]
      end

      def db_column_type
        field_class[field_type.to_sym][:db_column_type]
      end

      def similar_field_types
        self.class::CUSTOM_FIELD_POOLS[self.db_column_type]
      end

      def all_suitable_columns
        self.class::DB_COLUMNS[self.db_column_type][:columns]
      end

      def field_name
        name
      end

      def field_type
        self.class::FIELD_TYPE_NUMBER_TO_NAME[read_attribute(:field_type)] #generated by CustomField::Constants
      end

      def field_type= type
        write_attribute(:field_type, field_class[type.to_sym][:type])
      end

      def default_field?
        read_attribute(:field_type) < MAX_DEFAULT_FIELDS
      end

      def custom_field?
        !default_field?
      end

      def choices=(c_attr)
        @choices = c_attr
      end

      def dom_placeholder
        (placeholder = field_class[field_type.to_sym][:dom_placeholder]).nil? ? '' : I18n.t("#{placeholder}")
      end

      def default_field_label
       field_class[field_type.to_sym][:label] || ''
      end

      def bottom_note
        (bottom_note = field_class[field_type.to_sym][:bottom_note]).nil? ? '' : I18n.t("#{bottom_note}")
      end

      def regex # only for regex field
        if field_type.to_sym == :custom_text && field_options.is_a?(Hash)
          # Need to receive regex as two parts like rubular instead of splitting everytime while using
          dummy, pattern, flags = field_options['regex'].split("/")
          combined_flag_constant = 0

          if flags.present?
            flags.each_char do |c|
              case c
              when "i"
                combined_flag_constant |= Regexp::IGNORECASE
              when "m"
                combined_flag_constant |= Regexp::MULTILINE
              when "x"
                combined_flag_constant |= Regexp::EXTENDED
              end
            end
          end

          Regexp.new(pattern, combined_flag_constant)
        end
      end

      def choices(model = nil)
        case field_type
          when :"custom_dropdown" then
            return @choices.each    { |c| [c[0], c[0].to_sym] } unless @choices.nil? # to re-render choices while fields are with errors
            custom_field_choices.collect { |c| [c.value, c.value.to_sym] }
          when :"custom_survey_radio" then
            return @choices.each    { |c| [c[0], c[1]] } unless @choices.nil?
            custom_field_choices.collect { |c| [c.value, c.face_value] }
          when :"default_time_zone" then
            ActiveSupport::TimeZone.all.map do |time_zone| [time_zone.to_s, time_zone.name.to_sym] end
          when :"default_language" then
            I18n.available_locales_with_name
          else
           []
        end
      end

      def html_unescaped_choices(model = nil)
        case field_type
          when :"custom_dropdown" then
            return @choices.each    { |c| [CGI.unescapeHTML(c[0]), c[0].to_sym] } if @choices
            custom_field_choices.collect { |c| [CGI.unescapeHTML(c.value), c.value.to_sym] }
          when :"custom_survey_radio" then
            return @choices.each    { |c| [CGI.unescapeHTML(c[0]), c[0].to_sym] } if @choices
            custom_field_choices.collect { |c| [CGI.unescapeHTML(c.value), c.face_value.to_sym] }
          when :'default_time_zone' then
            ActiveSupport::TimeZone.all.map do |time_zone| [time_zone.to_s, time_zone.name.to_sym] end
          when :'default_language' then
            I18n.available_locales_with_name
          else
            []
         end
      end

      def default_value # Example to access return_account_property, Override at ur wish in ur model
        case field_type
          when :"default_time_zone" then
            return_account_property
          when :"default_language" then
            return_account_property
          else
            ''
        end
      end

      protected
        def populate_choices # Query Optimization # TODO
          return unless @choices
          if( :"custom_dropdown" == self.field_type && 
            custom_field_choices.collect{ |c| [c.value, c.value] } != @choices )
            custom_field_choices.clear
            @choices.each{ |c| custom_field_choices.build({:value => c[0]}) }
          elsif( :"custom_survey_radio" == self.field_type && 
            custom_field_choices.collect{ |c| [c.value, c.face_value] } != @choices )
            custom_field_choices.clear
            @choices.each{ |c| custom_field_choices.build({:value => c[0], :face_value => c[1]}) }
          end
        end
        
      private
        def return_account_property
          (account || Account.current).send(name)
        end
        
    end
  end
end